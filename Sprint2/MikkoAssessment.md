# Self-Assessment of Code

## Mikko Saarela

Here's a look at some of the frontend code I worked on. A few code snippets and explanations on choices.

### Prediction.jsx

To get each predictions voting to work as visioned required some thinking through.

The function checks on line 20 if the user has already voted with the same type. If the user has already voted and the vote type matches the current vote, the function removes the user's vote from the corresponding array (agrees or disagrees) using the splice method. It then sets the userVote state to null and exits the function. It then adds the user's new vote to the appropriate array based on the type parameter. Finally, the function updates the userVote state to reflect the new vote type. This function ensures that a user can only have one active vote at a time and can toggle their vote between 'agrees' and 'disagrees' or remove their vote entirely.

```js
const handleVote = (type) => {
  if (!user) return;

  // Check if user has voted
  if (userVote === type) {
    if (type === 'agrees') {
      agrees.splice(agrees.indexOf(user.id), 1);
    } else if (type === 'disagrees') {
      disagrees.splice(disagrees.indexOf(user.id), 1);
    }
    setUserVote(null);
    return;
  }

  if (type === 'agrees') {
    agrees.push(user.id);
  } else if (type === 'disagrees') {
    disagrees.push(user.id);
  }

  setUserVote(type);
};
```

So the user cannot vote on their own predictions, both the agree and disagree button are disabled when trying to vote on ones own prediction, by doing a check on userId's. This might later be changed, one other solution might be that the <div> containing the buttons would be conditionally rendered only if the prediction is another users.

```js
disabled={userId === user.id}
```

The code uses useEffect to keep the data on the current users votes up-to-date.

```js
useEffect(() => {
  if (user) {
    if (agrees.includes(user.id)) {
      setUserVote('agrees');
    } else if (disagrees.includes(user.id)) {
      setUserVote('disagrees');
    }
  }
}, [user, agrees, disagrees]);
```

### CommentModal.jsx

This component is a modal dialog that displays comments. The modal was designed with Tailwind CSS to match the general feel of the rest of the project.

From a user point of view the separate modal might not be best implementation so this might be changed later.

```js
<div className='fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50'>
  <div className='bg-card dark:bg-darkCard rounded-lg shadow-lg p-4 w-full max-w-lg'>
    <div className='flex justify-between items-center mb-4'>
      <h2>Comments</h2>
      <button onClick={onClose} className='text-gray-600 hover:text-gray-900'>
        &times;
      </button>
    </div>
    <div className='space-y-4'>
      {comments.map((comment) => (
        <Comment key={comment.id} comment={comment} onLike={handleLike} />
      ))}
    </div>
    <CommentInput
      predictionId={predictionId}
      onAddComment={handleAddComment}
      user={user}
    />
  </div>
</div>
```

### PredictionInput.jsx

The PredictionInput component works as has been practised frequently in the activities of the course. If either field is empty, it sets an error message indicating that both fields are required and exits the function early. If both fields are filled, the function proceeds to create a new prediction object.

After creating the new prediction object, the function calls addPrediction to add the new prediction to the list of predictions and addPredictionToUser to associate the prediction with the current user. This can be simplified later, once the database has been connected so we don't need to manage state in several places. The current implementation is to make the current, databaseless use experience more 'real'.

```js
const handlePostPrediction = () => {
  if (!predictionText || !lastVoteDate) {
    setError('Both fields are required.');
    return;
  }

  const newPrediction = {
    // Generated by mongodb
    id: mockData.predictions.length + 1,
    userId: user.id, // Replace with actual id
    username: user.username, // Replace with actual username
    prediction: predictionText,
    agrees: [],
    disagrees: [],
    lastVoteDate: lastVoteDate,
    avatar: user.avatar,
    comments: [],
  };

  addPrediction(newPrediction);
  addPredictionToUser(newPrediction);
  setPredictionText('');
  setLastVoteDate('');
  setError('');
};
```
